'''
다이나믹 프로그래밍은 동적 계획법이라고도 부릅니다.
다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있습니다.
1. 최적 부분 구조
- 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다.
2. 중복되는 부분 문제
- 동일한 작은 문제를 반복적으로 해결해야 합니다.

ex) 피보나치 수열 -> 1번과 2번 둘다 만족
단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간(2^n) 복잡도를 가지게 됩니다.

dp 구현방법은 상향식과 하향식이 있습니다.
하향식(top-down) 방식 -> 메모이제이션(Memoization)
한 번 계산한 결과를 메모리 공간에 메모하는 기법입니다.
- 같은 문제를 다시 호출하면 메모했던 결과를 가져옵니다.
- 값을 기록해 놓는다는 점에서 캐싱이라고도 합니다.

상향식(bottum-up) - 전형적인 형태
- 결과 저장용 리스트는 DP테이블이라고 부릅니다.
엄밀히 말하면 메모제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미합니다.
- 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다.
- 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.
'''

N = int(input())
d = [0]*100
memo = {}
def fi(x):
    if x == 1 or x ==2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x]!= 0:
        return d[x]
    d[x] = fi(x-1) + fi(x-2)
    return d[x]

print(fi(N))

def fibo5(x):
    if x == 1 or x == 2:
        return 1
    if x in memo:
        return memo[x]
    memo[x] = fibo5(x-1) + fibo5(x-2)
    return memo[x]

print(fibo5(N))
